<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¼«éŠé›™æºªç²¾å½©ç¥æ•æ‰éŠæˆ²ç³»çµ±</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #2a003f 100%); /* æ·±è—ç´«æ¼¸è®Šï¼Œç§‘æŠ€æ„ŸèƒŒæ™¯ */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            color: #e0e7ff; /* æ·ºè—è‰²æ–‡å­— */
            transition: background-color 0.5s;
            position: relative;
        }

        #game-wrapper {
            background-color: rgba(30, 30, 50, 0.7); /* åŠé€æ˜æ·±è‰²èƒŒæ™¯ */
            backdrop-filter: blur(10px); /* ç£¨ç ‚ç»ç’ƒæ•ˆæœ */
            -webkit-backdrop-filter: blur(10px); /* å…¼å®¹ Safari */
            border-radius: 1.5rem;
            box-shadow: 0 10px 60px rgba(0, 0, 0, 0.5), 0 0 30px rgba(100, 50, 255, 0.3); /* å¸¶æœ‰ç§‘æŠ€å…‰æšˆçš„é™°å½± */
            width: 95vw;
            max-width: 700px;
            padding: 1.5rem;
            z-index: 10; 
            border: 1px solid rgba(120, 80, 255, 0.4); /* è¼•å¾®é‚Šæ¡† */
            display: none; /* åˆå§‹éš±è—ï¼Œè¼‰å…¥å®Œæˆå¾Œé¡¯ç¤º */
        }

        #canvas-container {
            position: relative;
            background: linear-gradient(180deg, #3a005f 0%, #5a007f 100%); /* é®®è±”ç´«æ¼¸è®Š */
            border-radius: 1rem;
            border: 4px solid #00c4ff; /* éœ“è™¹è—é‚Šæ¡† */
            overflow: hidden;
            touch-action: none;
            min-height: 400px;
            box-shadow: inset 0 0 15px rgba(0, 196, 255, 0.5); /* å…§éƒ¨å…‰æšˆ */
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 400px;
            cursor: pointer;
        }

        .status-bar-item {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            color: #e0e7ff; /* æ·ºè—è‰²æ–‡å­— */
            background-color: rgba(255, 255, 255, 0.1); /* åŠé€æ˜æ·ºè‰²èƒŒæ™¯ */
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        /* ç‰¹æ®Šç‹€æ…‹æ¬„é¡è‰² */
        .status-bar-item#level-display-wrapper { background-color: rgba(100, 255, 200, 0.1); border-color: rgba(100, 255, 200, 0.3); }
        .status-bar-item#timer-display-wrapper { background-color: rgba(255, 100, 150, 0.1); border-color: rgba(255, 100, 150, 0.3); }
        .status-bar-item#score-display-wrapper { background-color: rgba(100, 150, 255, 0.1); border-color: rgba(100, 150, 255, 0.3); }


        .game-button {
            padding: 0.6rem 2rem;
            background: linear-gradient(145deg, #8a2be2, #c080ff); /* é®®è±”ç´«æ¼¸è®Š */
            color: #ffffff;
            font-weight: 900;
            font-size: 1.1rem;
            border-radius: 9999px;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.5), 0 0 20px rgba(192, 128, 255, 0.7); /* å¸¶æœ‰å…‰æšˆçš„é™°å½± */
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.8), 0 0 30px rgba(192, 128, 255, 0.9);
        }

        /* å‰ç¥¥ç‰©æ¨£å¼ (é é¢å·¦ä¸‹è§’å›ºå®š) */
        #mascot-fixed {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 80px; 
            height: auto;
            cursor: pointer;
            z-index: 5; 
            transition: transform 0.2s ease-out, filter 0.2s ease-out; 
            filter: drop-shadow(0 2px 5px rgba(0,0,0,0.5)); /* è¼•å¾®é™°å½± */
        }

        /* æŠ–å‹•å‹•ç•«ï¼Œèª¿æ•´ç‚ºæ›´è‡ªç„¶çš„å¾®å…‰æ•ˆæœ */
        @keyframes natural-glow {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 8px rgba(0, 196, 255, 0.5)); } /* éœ“è™¹è—å…‰ */
            50% { transform: scale(1.02); filter: drop-shadow(0 0 15px rgba(138, 43, 226, 0.7)); } /* é®®è±”ç´«å…‰ */
        }

        #mascot-fixed:hover {
            animation: natural-glow 1.5s infinite ease-in-out; 
        }

        /* ç‰ˆæ¬Šä¿¡æ¯æ¨£å¼ */
        #copyright {
            margin-top: 2rem;
            font-size: 0.9rem;
            color: #9cadc0; /* æ·ºç°è‰² */
            text-align: center;
            z-index: 10;
        }

        /* éŠæˆ²èªªæ˜æ›¸æ¨£å¼ */
        #instructions-modal {
            background-color: rgba(0, 0, 0, 0.85); /* æ›´æ·±çš„åŠé€æ˜èƒŒæ™¯ */
            z-index: 50;
        }
        #instructions-modal .modal-content { /* è‡ªå®šç¾© class é¿å… Tailwind è¡çª */
            background-color: #2c004a; /* èªªæ˜æ›¸èƒŒæ™¯ï¼šæ·±ç´« */
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(192, 128, 255, 0.4);
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.6);
        }

        /* éŠæˆ²æŒ‰éˆ•è¦†è“‹å±¤ */
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 20; 
            background: rgba(30,30,50,0.6); /* è¼•å¾®èƒŒæ™¯ï¼Œè®“æ–‡å­—æ›´æ¸…æ™° */
            border-radius: 1rem;
            transition: opacity 0.3s ease-in-out;
            opacity: 1;
        }

        #game-overlay.hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }
        #game-overlay:not(.hidden) {
            display: flex; 
        }

        #game-overlay > * {
            pointer-events: auto;
        }

        /* ä¸»æ¨™é¡Œå…§çš„èªªæ˜æŒ‰éˆ• */
        #title-instructions-button {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: #00c4ff; /* éœ“è™¹è— */
            transition: color 0.2s;
        }
        #title-instructions-button:hover {
            color: #8a2be2; /* é®®è±”ç´« */
        }
        @media (min-width: 640px) {
            #title-instructions-button {
                right: 1rem;
            }
        }

        /* ç‰©å“å°åœ–æ¨™åœ¨æ–‡å­—ä¸­çš„æ¨£å¼ */
        .item-icon-inline {
            height: 1.5em;
            width: auto;
            vertical-align: middle;
            margin: 0 0.2em;
            display: inline-block;
        }
        /* ç¢ºä¿æ¯å€‹ä»»å‹™é …ç›®çš„åœ–ç‰‡å’Œæ–‡å­—ä¸æœƒæ–·é–‹ */
        .mission-item-wrapper {
            display: inline-flex;
            align-items: center;
            white-space: nowrap;
            margin-right: 1rem;
        }
        /* ä»»å‹™ç›®æ¨™å€çš„æ–‡å­— flex å®¹å™¨ */
        #mission-display .flex-wrap {
            display: flex;
            flex-wrap: wrap;
            gap: 0;
        }

        /* èƒŒæ™¯éŸ³æ¨‚æ§åˆ¶å€ */
        #music-controls {
            background-color: rgba(30, 30, 50, 0.7); /* åŠé€æ˜æ·±è‰² */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 0.75rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 196, 255, 0.2);
            padding: 0.75rem 1.5rem;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            color: #e0e7ff; /* æ·ºè—è‰²æ–‡å­— */
            border: 1px solid rgba(120, 80, 255, 0.3);
            z-index: 10;
        }
        #music-controls.hidden {
            display: none;
        }
        #music-toggle-button {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: #00c4ff; /* éœ“è™¹è— */
            transition: color 0.2s;
        }
        #music-toggle-button:hover {
            color: #8a2be2; /* é®®è±”ç´« */
        }
        #music-volume-slider {
            width: 80px;
            height: 8px;
            background: transparent; 
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none; 
            appearance: none;
            /* åˆå§‹èƒŒæ™¯ç”±JSè¨­å®š */
        }
        /* é‡å° Webkit ç€è¦½å™¨ (Chrome, Safari) çš„æ»‘æ¡¿è»Œé“ */
        #music-volume-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: transparent; /* è®“JSæ§åˆ¶èƒŒæ™¯ */
            border-radius: 4px;
            -webkit-appearance: none; 
        }
        /* é‡å° Firefox çš„æ»‘æ¡¿è»Œé“ */
        #music-volume-slider::-moz-range-track {
            width: 100%;
            height: 8px;
            background: transparent; /* è®“JSæ§åˆ¶èƒŒæ™¯ */
            border-radius: 4px;
        }
        #music-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e0e7ff; /* æ·ºè—è‰² */
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 196, 255, 0.7);
            margin-top: -4px; 
        }
        #music-volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e0e7ff; /* æ·ºè—è‰² */
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 196, 255, 0.7);
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #2a003f 100%); /* èˆ‡bodyèƒŒæ™¯ä¸€è‡´ */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #e0e7ff;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 100;
            transition: opacity 0.5s ease;
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #00c4ff; /* éœ“è™¹è— */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Score breakdown style */
        #score-breakdown {
            margin-top: 1rem;
            background-color: rgba(0,0,0,0.4);
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 1rem;
            color: #e0e7ff;
            text-align: left;
            width: 80%;
            max-width: 300px;
        }
        #score-breakdown p {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }
        #score-breakdown p span:first-child {
            color: #9cadc0;
        }
        #score-breakdown .total-score {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00c4ff; /* éœ“è™¹è— */
            border-top: 1px dashed rgba(255,255,255,0.3);
            padding-top: 0.5rem;
            margin-top: 0.5rem;
        }

    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p>è¼‰å…¥ä¸­ï¼Œè«‹ç¨å€™...</p>
    </div>

    <div id="game-wrapper">
        <h1 class="text-3xl font-extrabold mb-4 text-center text-blue-300 relative">
            æ¼«éŠé›™æºªç²¾å½©ç¥æ•æ‰éŠæˆ²ç³»çµ±
            <button id="title-instructions-button">
                <i class="fas fa-info-circle text-2xl"></i>
            </button>
        </h1>
        
        <!-- ç‹€æ…‹æ¬„ï¼šé—œå¡ã€æ™‚é–“ã€åˆ†æ•¸ -->
        <div class="flex justify-between items-center mb-4 p-2 rounded-xl" style="background-color: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);">
            <div id="level-display-wrapper" class="status-bar-item"><span class="text-green-300">é—œå¡:</span> <span id="level-display">0</span></div>
            <div id="timer-display-wrapper" class="status-bar-item text-2xl"><span class="text-pink-300">æ™‚é–“:</span> <span id="timer-display">0.0</span>s</div>
            <div id="score-display-wrapper" class="status-bar-item"><span class="text-blue-300">å¾—åˆ†:</span> <span id="score-display">0</span></div>
        </div>

        <!-- ä»»å‹™ç›®æ¨™å€ -->
        <div id="mission-display" class="mb-4 p-4 rounded-lg bg-purple-900/40 border-l-4 border-blue-400 text-white">
            <h2 class="text-xl font-bold mb-2 text-blue-300"><i class="fas fa-bullseye"></i> ä»»å‹™ç›®æ¨™:</h2>
            <div class="flex flex-wrap text-lg">
                <p><i class="fas fa-camera-retro text-green-300"></i> æ•æ‰: <span id="targets" class="font-bold text-green-300">...</span></p>
                <p class="ml-4"><i class="fas fa-ban text-red-300"></i> é¿é–‹: <span id="forbidden" class="font-bold text-red-300">...</span></p>
            </div>
            <p id="level-name" class="text-sm mt-2 italic text-gray-300">éŠæˆ²å°šæœªé–‹å§‹</p>
        </div>

        <!-- ç•«å¸ƒå®¹å™¨ -->
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <!-- éŠæˆ²è¨Šæ¯èˆ‡æŒ‰éˆ•è¦†è“‹å±¤ -->
            <div id="game-overlay">
                <p id="game-message" class="text-lg text-white mb-4 text-center drop-shadow-lg"></p>
                <!-- Score breakdown will be inserted here dynamically -->
                <div id="score-breakdown" class="hidden"></div> 
                <button id="start-button" class="game-button"></button>
            </div>
        </div>

    </div>

    <!-- èƒŒæ™¯éŸ³æ¨‚æ§åˆ¶å€ -->
    <div id="music-controls">
        <button id="music-toggle-button">
            <i class="fas fa-volume-up"></i> <!-- åˆå§‹ç‚ºæ’­æ”¾ç‹€æ…‹ -->
        </button>
        <input type="range" id="music-volume-slider" min="0" max="1" step="0.05" value="0.3">
    </div>

    <!-- å‰ç¥¥ç‰©åœ–ç‰‡ (é é¢å·¦ä¸‹è§’å›ºå®š) -->
    <img id="mascot-fixed" src="image/LiyuChillGuy.svg" alt="å‰ç¥¥ç‰©LiyuChillGuy">

    <!-- ç‰ˆæ¬Šä¿¡æ¯ -->
    <div id="copyright">
        <p>Copyright Â© Liyuchiutiger Gongminshen</p>
    </div>

    <!-- éŠæˆ²èªªæ˜æ›¸ Modal -->
    <div id="instructions-modal" class="fixed inset-0 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content rounded-lg p-6 max-w-lg w-full text-white shadow-xl relative">
            <h2 class="text-2xl font-bold mb-4 text-blue-300"><i class="fas fa-gamepad"></i> æ¼«éŠé›™æºªç¥ç…§ç²¾å½©éŠæˆ²èªªæ˜</h2>
            <button class="absolute top-3 right-3 text-gray-400 hover:text-white text-3xl font-bold" onclick="gameInstance.toggleInstructions()">&times;</button>
            
            <p class="mb-3">æ­¡è¿ä¾†åˆ°æ¼«éŠé›™æºªç¥è¿½å½±æ•æ‰æŒ‘æˆ°ï¼ä½ çš„ä»»å‹™æ˜¯åœ¨é™æ™‚å…§ï¼Œæ•æ‰åˆ°é—œå¡æŒ‡å®šçš„æ‰€æœ‰ã€Œç›®æ¨™ã€ï¼ŒåŒæ™‚ã€Œé¿é–‹ã€æ‰€æœ‰ç¦å¿Œç‰©å“ã€‚</p>
            
            <h3 class="text-xl font-bold mt-4 mb-2 text-green-300"><i class="fas fa-crosshairs"></i> å¦‚ä½•éŠç©:</h3>
            <ul class="list-disc list-inside mb-3 space-y-1">
                <li>éŠæˆ²å€åŸŸå…§æœƒæ¼‚æµ®è‘—å„ç¨®é›™æºªå…ƒç´  (ä¾‹å¦‚ï¼š<span class="mission-item-wrapper"><img src="item/Good shot.svg" alt="Good shot" class="item-icon-inline">Good shot</span>ã€<span class="mission-item-wrapper"><img src="item/äººç”Ÿå±±è€€.svg" alt="äººç”Ÿå±±è€€" class="item-icon-inline">äººç”Ÿå±±è€€</span>ã€<span class="mission-item-wrapper"><img src="item/å¤©åœ°æœ‰æ­£æ°£.svg" alt="å¤©åœ°æœ‰æ­£æ°£" class="item-icon-inline">å¤©åœ°æœ‰æ­£æ°£</span>ã€<span class="mission-item-wrapper"><img src="item/å¹³å®‰é †åˆ©.svg" alt="å¹³å®‰é †åˆ©" class="item-icon-inline">å¹³å®‰é †åˆ©</span>)ã€‚</li>
                <li>é»æ“Šç•«é¢ä»»ä½•ä½ç½®ï¼Œå³æœƒè§¸ç™¼ä¸€æ¬¡ã€Œå…¨è¢å¹•å¿«ç…§ã€ã€‚</li>
                <li><strong class="text-red-300">å¦‚æœå¿«ç…§ä¸­å‡ºç¾ä»¥ä¸‹ä»»ä½•ç¦å¿Œç‰©å“ï¼Œä½ å°‡ç«‹å³å¤±æ•—ï¼</strong></li>
                <li id="instructions-forbidden-list" class="flex flex-wrap pl-5 mb-2">
                    <!-- Dynamic forbidden items will be inserted here -->
                </li>
                <li>å¦‚æœå¿«ç…§ä¸­åŒæ™‚å‡ºç¾æ‰€æœ‰ã€Œä»»å‹™ç›®æ¨™ã€ï¼Œä¸”æ²’æœ‰ä»»ä½•ç¦å¿Œç‰©å“ï¼Œä½ å°‡æˆåŠŸæ™‰ç´šï¼</li>
                <li>æ•æ‰ <span class="mission-item-wrapper"><img src="item/ç¥¥æ—ºä¾†ç¦.svg" alt="ç¥¥æ—ºä¾†ç¦" class="item-icon-inline">ç¥¥æ—ºä¾†ç¦</span>å¯ç²å¾—é¡å¤–çå‹µåˆ†æ•¸ï¼Œä½†åƒ…é™åœ¨æˆåŠŸæ™‰ç´šçš„å›åˆï¼</li>
                <li>é»æ“Šã€Œä¸‹ä¸€é—œã€æˆ–ã€Œå†è©¦ä¸€æ¬¡ã€æ‰æœƒè®“ç‰©ä»¶é‡æ–°ç§»å‹•ã€‚å¦‚æœå¿«ç…§æ²’æœ‰å°è‡´æ™‰ç´šæˆ–å¤±æ•—ï¼Œæœƒå‡ºç¾ã€Œç¹¼çºŒæ•æ‰ã€æŒ‰éˆ•ï¼Œé»æ“Šå¾Œç‰©ä»¶ä¹Ÿæœƒæ¢å¾©ç§»å‹•ã€‚</li>
            </ul>

            <h3 class="text-xl font-bold mt-4 mb-2 text-blue-300"><i class="fas fa-star"></i> éŠæˆ²æç¤º:</h3>
            <ul class="list-disc list-inside space-y-1">
                <li>æ¯å€‹é—œå¡çš„æ™‚é–“å’Œç›®æ¨™éƒ½ä¸åŒï¼Œè«‹ä»”ç´°æŸ¥çœ‹ã€‚</li>
                <li>éŠæˆ²æœƒéš¨è‘—é—œå¡æ¨é€²è€Œå¢åŠ é›£åº¦ï¼Œç‰©å“ç§»å‹•é€Ÿåº¦æœƒè®Šå¿«ï¼</li>
                <li>ç²¾æº–åˆ¤æ–·å¿«ç…§æ™‚æ©Ÿæ˜¯ç²å‹çš„é—œéµï¼</li>
            </ul>
            <button class="game-button mt-6 w-full" onclick="gameInstance.toggleInstructions()">æˆ‘çŸ¥é“äº†ï¼</button>
        </div>
    </div>

    <!-- èƒŒæ™¯éŸ³æ¨‚ Audio Element -->
    <audio id="background-music" loop preload="auto">
        <source src="audio/bgm.mp3" type="audio/mpeg">
        æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æŒéŸ³é »å…ƒç´ ã€‚è«‹ç¢ºèª `audio/bgm.mp3` æ–‡ä»¶å­˜åœ¨ã€‚
    </audio>

    <script>
        // --- éŠæˆ²è¨­å®šèˆ‡åˆå§‹åŒ– ---
        const SCALE_FACTOR = 2; // ç”¨æ–¼å…§éƒ¨è¨ˆç®—ï¼Œå½±éŸ¿ç‰©ä»¶å¤§å°å’Œä½ç½®
        const SCORE_PER_CAPTURE = 100; // å®Œæˆé—œå¡çš„åŸºæœ¬åˆ†
        const BONUS_ITEM_SCORE = 200; // ç¥¥æ—ºä¾†ç¦çš„çå‹µåˆ†æ•¸
        const TIME_BONUS_MULTIPLIER = 50; // æ¯ç§’å‰©é¤˜æ™‚é–“çš„åˆ†æ•¸
        const TARGET_BONUS_PER_ITEM = 50; // æ¯æ•æ‰ä¸€å€‹ç›®æ¨™çš„é¡å¤–åˆ†æ•¸ (å¦‚æœæœ‰å¤šå€‹ç›®æ¨™)

        // åœ–ç‰‡å®šç¾©ï¼ŒåŒ…å«è·¯å¾‘ã€åŸºç¤å°ºå¯¸ã€é€Ÿåº¦ã€åç¨±ã€æ˜¯å¦ç‚ºçå‹µã€Font Awesome åœ–æ¨™é¡åˆ¥
        const ORIGINAL_IMAGE_DEFINITIONS = {
            GOOD_SHOT: { path: 'item/Good shot.svg', size: 30 * SCALE_FACTOR, speed: 1.0, name: 'Good shot', iconClass: 'fas fa-bullseye' },
            REN_SHENG_SHAN_YAO: { path: 'item/äººç”Ÿå±±è€€.svg', size: 30 * SCALE_FACTOR, speed: 1.2, name: 'äººç”Ÿå±±è€€', iconClass: 'fas fa-mountain' },
            TIAN_DI_YOU_ZHENG_QI: { path: 'item/å¤©åœ°æœ‰æ­£æ°£.svg', size: 30 * SCALE_FACTOR, speed: 1.1, name: 'å¤©åœ°æœ‰æ­£æ°£', iconClass: 'fas fa-cloud-moon' },
            PING_AN_SHUN_LI: { path: 'item/å¹³å®‰é †åˆ©.svg', size: 30 * SCALE_FACTOR, speed: 0.9, name: 'å¹³å®‰é †åˆ©', iconClass: 'fas fa-handshake' },
            HAO_YE_JIANG_FA: { path: 'item/å¥½é‡å°‡ç™¼.svg', size: 35 * SCALE_FACTOR, speed: 2.0, name: 'å¥½é‡å°‡ç™¼', iconClass: 'fas fa-dollar-sign' }, 
            HAO_YUN_LONG_HOU_LI: { path: 'item/å¥½é‹é¾åšå“©.svg', size: 30 * SCALE_FACTOR, speed: 1.3, name: 'å¥½é‹é¾åšå“©', iconClass: 'fas fa-dragon' },
            HAO_YUN_CHONG_LONG_WANG: { path: 'item/å¥½é‹è½Ÿéš†æ—º.svg', size: 30 * SCALE_FACTOR, speed: 1.0, name: 'å¥½é‹èŸ²éš†æ—º', iconClass: 'fas fa-bug' },
            HAO_LUN_YI_SHENG_PING_AN: { path: 'item/å¥½è¼ªä¸€ç”Ÿå¹³å®‰.svg', size: 30 * SCALE_FACTOR, speed: 1.4, name: 'å¥½è¼ªä¸€ç”Ÿå¹³å®‰', iconClass: 'fas fa-tire' },
            BEN_PAO_BA: { path: 'item/å¥”è·‘å§.svg', size: 30 * SCALE_FACTOR, speed: 1.5, name: 'å¥”è·‘å§', iconClass: 'fas fa-running' },
            XIAN_QIN_YI_ZHI: { path: 'item/å¼¦ç´é€¸è‡´.svg', size: 30 * SCALE_FACTOR, speed: 0.8, name: 'å¼¦ç´é€¸è‡´', iconClass: 'fas fa-guitar' },
            SUO_ZAI_JIE_HE_SUO_ZAI: { path: 'item/æ‰€åœ¨çš†è·æ‰€åœ¨.svg', size: 30 * SCALE_FACTOR, speed: 1.2, name: 'æ‰€åœ¨çš†è·æ‰€åœ¨', iconClass: 'fas fa-map-marker-alt' },
            XIANG_KAN_LIANG_BU_YAN: { path: 'item/ç›¸çœ‹å…©ä¸å­.svg', size: 30 * SCALE_FACTOR, speed: 1.1, name: 'ç›¸çœ‹å…©ä¸å­', iconClass: 'fas fa-eye' },
            XIANG_WANG_LAI_FU: { path: 'item/ç¥¥æ—ºä¾†ç¦.svg', size: 30 * SCALE_FACTOR, speed: 1.0, name: 'ç¥¥æ—ºä¾†ç¦', isBonus: true, iconClass: 'fas fa-dog' }, // è®Šç‚ºçå‹µç‰©å“
            YAO_SHEN_YI_BIAN: { path: 'item/çª¯èº«ä¸€è®Š.svg', size: 30 * SCALE_FACTOR, speed: 1.6, name: 'çª¯èº«ä¸€è®Š', iconClass: 'fas fa-fire-alt' },
            SHUANG_XI_LIN_MEN: { path: 'item/é›™å–œè‡¨é–€.svg', size: 30 * SCALE_FACTOR, speed: 1.3, name: 'é›™å–œè‡¨é–€', iconClass: 'fas fa-door-open' },
            XIE_XIE_YOU_NIN: { path: 'item/èŸ¹èŸ¹æœ‰æ‚¨.svg', size: 35 * SCALE_FACTOR, speed: 2.2, name: 'èŸ¹èŸ¹æœ‰æ‚¨', iconClass: 'fas fa-radiation-alt' }, 
        };

        const OBJECT_TYPES = {}; // è¼‰å…¥åœ–ç‰‡å¾Œå°‡è£œå…… img å±¬æ€§

        // å…¨å±€ç¦å¿Œç‰©å“ï¼Œç„¡è«–åœ¨å“ªå€‹é—œå¡å‡ºç¾éƒ½æœƒå°è‡´å¤±æ•—
        const GLOBAL_FORBIDDEN_ITEMS = ['XIANG_KAN_LIANG_BU_YAN', 'TIAN_DI_YOU_ZHENG_QI'];

        // é—œå¡æ•¸æ“š (å·²æ›´æ–°ç‚ºæ–°çš„åœ–ç‰‡ï¼Œä¸¦èª¿æ•´äº†éƒ¨åˆ†é›£åº¦)
        const LEVELS = [
            {
                name: "æ•æ‰ç²¾å½©ç¬é–“",
                duration: 12, // ç§’
                required: ['GOOD_SHOT'],
                forbidden: GLOBAL_FORBIDDEN_ITEMS, 
                objectCount: 8,
                speedMultiplier: 1.0,
                bonusItemChance: 0.2 // çå‹µç‰©å“å‡ºç¾æ©Ÿç‡
            },
            {
                name: "äººç”Ÿå¹³å®‰",
                duration: 10,
                required: ['REN_SHENG_SHAN_YAO', 'PING_AN_SHUN_LI'],
                forbidden: GLOBAL_FORBIDDEN_ITEMS,
                objectCount: 12,
                speedMultiplier: 1.2,
                bonusItemChance: 0.25
            },
            {
                name: "æ­£æ°£èˆ‡å¥½é‹",
                duration: 10,
                required: ['HAO_YUN_LONG_HOU_LI'],
                forbidden: GLOBAL_FORBIDDEN_ITEMS,
                objectCount: 13,
                speedMultiplier: 1.3,
                bonusItemChance: 0.3
            },
            {
                name: "å¥”è·‘èˆ‡ç´éŸ³",
                duration: 9,
                required: ['BEN_PAO_BA', 'XIAN_QIN_YI_ZHI'], 
                forbidden: GLOBAL_FORBIDDEN_ITEMS,
                objectCount: 14,
                speedMultiplier: 1.4,
                bonusItemChance: 0.3
            },
            {
                name: "å¹³å®‰å¥½é‹ä¸€ç”Ÿ", 
                duration: 12, 
                required: ['GOOD_SHOT', 'HAO_YUN_LONG_HOU_LI', 'HAO_LUN_YI_SHENG_PING_AN'], 
                forbidden: GLOBAL_FORBIDDEN_ITEMS, 
                objectCount: 16,
                speedMultiplier: 1.3, 
                bonusItemChance: 0.35
            },
            {
                name: "é›™å–œè‡¨é–€å¥½é‹",
                duration: 10,
                required: ['SHUANG_XI_LIN_MEN', 'HAO_YUN_CHONG_LONG_WANG'],
                forbidden: GLOBAL_FORBIDDEN_ITEMS, 
                objectCount: 15,
                speedMultiplier: 1.5,
                bonusItemChance: 0.35
            },
            {
                name: "æ‰€åœ¨çš†è·",
                duration: 10,
                required: ['SUO_ZAI_JIE_HE_SUO_ZAI'],
                forbidden: GLOBAL_FORBIDDEN_ITEMS,
                objectCount: 17,
                speedMultiplier: 1.6,
                bonusItemChance: 0.4
            },
            {
                name: "ç¥¥æ—ºèˆ‡çª¯è®Š", 
                duration: 10, 
                required: ['XIANG_WANG_LAI_FU', 'YAO_SHEN_YI_BIAN'],
                forbidden: GLOBAL_FORBIDDEN_ITEMS, 
                objectCount: 16, 
                speedMultiplier: 1.5, 
                bonusItemChance: 0.4
            },
            {
                name: "æŒ‘æˆ°æ¥µé™", 
                duration: 10, 
                required: ['GOOD_SHOT', 'REN_SHENG_SHAN_YAO'], 
                forbidden: [...GLOBAL_FORBIDDEN_ITEMS, 'HAO_YUN_CHONG_LONG_WANG'], // é¡å¤–å¢åŠ ä¸€å€‹ç¦å¿Œ
                objectCount: 18, 
                speedMultiplier: 1.7, 
                bonusItemChance: 0.45
            },
            {
                name: "ç¥ç…§å¤§å¸«", 
                duration: 10, 
                required: ['GOOD_SHOT', 'REN_SHENG_SHAN_YAO', 'PING_AN_SHUN_LI'],
                forbidden: [...GLOBAL_FORBIDDEN_ITEMS, 'XIE_XIE_YOU_NIN'], // é¡å¤–å¢åŠ ä¸€å€‹ç¦å¿Œ
                objectCount: 22, 
                speedMultiplier: 2.0, 
                bonusItemChance: 0.5
            },
        ];

        // --- éŠæˆ²å°è±¡é¡åˆ¥ ---
        class GameObject {
            constructor(typeId, canvasWidth, canvasHeight) { // å‚³å…¥ç•«å¸ƒå°ºå¯¸
                const typeDef = OBJECT_TYPES[typeId]; 
                this.typeId = typeId;
                this.img = typeDef.img; 
                this.size = typeDef.size; 
                // è®“ç‰©ä»¶å¾ç•«å¸ƒé‚Šç·£å¤–å‡ºç¾
                this.x = Math.random() * canvasWidth;
                this.y = Math.random() < 0.5 ? -this.size : canvasHeight + this.size; 
                this.baseSpeed = typeDef.speed;
                this.vx = (Math.random() - 0.5) * 0.5; // éš¨æ©Ÿæ°´å¹³é€Ÿåº¦
                this.vy = this.y < canvasHeight / 2 ? 1 : -1; // æ ¹æ“šå‡ºç¾ä½ç½®æ±ºå®šåˆå§‹å‚ç›´æ–¹å‘
                this.isBonus = typeDef.isBonus || false; 
                this.name = typeDef.name; 
                this.iconClass = typeDef.iconClass; 
                this.miniHtmlImg = typeDef.miniHtmlImg; 
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
            }

            isVisibleOnCanvas() {
                // åˆ¤æ–·ç‰©ä»¶æ˜¯å¦è‡³å°‘éƒ¨åˆ†åœ¨ç•«å¸ƒå…§
                return (
                    this.x + this.size / 2 > 0 && 
                    this.x - this.size / 2 < this.canvasWidth && 
                    this.y + this.size / 2 > 0 && 
                    this.y - this.size / 2 < this.canvasHeight
                );
            }

            update(speedMultiplier) {
                if (gameInstance.objectsAreFrozen) return; 

                this.x += this.vx * this.baseSpeed * speedMultiplier;
                this.y += this.vy * this.baseSpeed * speedMultiplier;

                // é‚Šç•Œåå½ˆ
                if (this.x - this.size / 2 < 0 || this.x + this.size / 2 > this.canvasWidth) {
                    this.vx *= -1;
                    if (this.x - this.size / 2 < 0) this.x = this.size / 2;
                    if (this.x + this.size / 2 > this.canvasWidth) this.x = this.canvasWidth - this.size / 2;
                }
            }

            isOffScreen() {
                // åˆ¤æ–·ç‰©ä»¶æ˜¯å¦å®Œå…¨é›¢é–‹ç•«é¢
                return (this.y < -this.size * 2 || this.y > this.canvasHeight + this.size * 2);
            }

            draw() {
                // åªæœ‰ç•¶åœ–ç‰‡è¼‰å…¥æˆåŠŸæ™‚æ‰ç¹ªè£½
                if (!this.img) {
                    // åœ–ç‰‡è¼‰å…¥å¤±æ•—æ™‚çš„å‚™ç”¨é¡¯ç¤º (å¯ç§»é™¤ï¼Œå› ç‚º OBJECT_TYPES å·²ç¯©é¸ null)
                    gameInstance.ctx.fillStyle = 'gray';
                    gameInstance.ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                    gameInstance.ctx.fillStyle = 'white';
                    gameInstance.ctx.font = `${this.size/3}px Arial`;
                    gameInstance.ctx.fillText(this.typeId, this.x, this.y);
                    return;
                }

                gameInstance.ctx.save();
                gameInstance.ctx.textAlign = 'center';
                gameInstance.ctx.textBaseline = 'middle';
                gameInstance.ctx.globalAlpha = 1.0; 
                
                gameInstance.ctx.drawImage(this.img, this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                
                gameInstance.ctx.restore();
            }
        }

        // --- Game Class ---
        class Game {
            constructor() {
                // DOM Elements
                this.loadingOverlay = document.getElementById('loading-overlay');
                this.gameWrapper = document.getElementById('game-wrapper');
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.timerDisplay = document.getElementById('timer-display');
                this.levelDisplay = document.getElementById('level-display');
                this.scoreDisplay = document.getElementById('score-display');
                this.targetsDisplay = document.getElementById('targets');
                this.forbiddenDisplay = document.getElementById('forbidden');
                this.levelNameDisplay = document.getElementById('level-name');
                this.gameMessage = document.getElementById('game-message');
                this.startButton = document.getElementById('start-button');
                this.gameOverlay = document.getElementById('game-overlay');
                this.instructionsModal = document.getElementById('instructions-modal');
                this.titleInstructionsButton = document.getElementById('title-instructions-button');
                this.instructionsForbiddenList = document.getElementById('instructions-forbidden-list');
                this.scoreBreakdownElement = document.getElementById('score-breakdown'); // New element

                // Audio Elements
                this.bgmAudio = document.getElementById('background-music');
                this.musicToggleButton = document.getElementById('music-toggle-button');
                this.musicVolumeSlider = document.getElementById('music-volume-slider');
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Game State Variables
                this.canvasWidth = 0;
                this.canvasHeight = 400; // å›ºå®šé«˜åº¦
                this.gameState = 'loading'; // 'loading', 'ready', 'playing', 'win', 'lose'
                this.gameObjects = [];
                this.score = 0; // Total accumulated score
                this.currentLevelScore = 0; // Score for the current level
                this.currentLevelIndex = 0;
                this.captureEffect = null;
                this.highlightEffect = null;
                this.bonusMessages = [];
                this.objectsAreFrozen = false;
                this.animationFrameId = null;

                // Time Management for rAF
                this.gameStartTime = 0;
                this.lastFrameTime = 0;
                this.timeLeft = 0;

                // Asset Loading
                this.totalImagesToLoad = Object.keys(ORIGINAL_IMAGE_DEFINITIONS).length;
                this.imagesLoadedCount = 0;
                this.imagesLoadedMap = {}; // Use a map to store loaded Image objects
                this.fontAwesomeLoaded = false;
                this.mascotLoaded = false;
                this.backgroundMusicPlayedOnceSuccessfully = false; // For autoplay handling
            }

            // --- Initialization and Asset Loading ---
            async init() {
                this.setupEventListeners();
                // resizeCanvas will be called after gameWrapper is visible in postLoadSetup
                window.addEventListener('resize', () => this.resizeCanvas());

                // Load Font Awesome
                document.fonts.ready.then(() => {
                    this.fontAwesomeLoaded = true;
                    this.checkAllAssetsLoaded();
                }).catch(err => {
                    console.error("Font Awesome å­—é«”è¼‰å…¥å¤±æ•—:", err);
                    this.fontAwesomeLoaded = true; // Assume loaded to avoid blocking
                    this.checkAllAssetsLoaded();
                });

                // Load Mascot Image (just check existence)
                const mascotImg = document.getElementById('mascot-fixed');
                if (mascotImg.complete) {
                    this.mascotLoaded = true;
                    this.checkAllAssetsLoaded();
                } else {
                    mascotImg.onload = () => {
                        this.mascotLoaded = true;
                        this.checkAllAssetsLoaded();
                    };
                    mascotImg.onerror = () => {
                        console.warn("å‰ç¥¥ç‰©åœ–ç‰‡è¼‰å…¥å¤±æ•—.");
                        this.mascotLoaded = true; // Still mark as loaded to not block game
                        this.checkAllAssetsLoaded();
                    };
                }

                // Pre-populate OBJECT_TYPES with definitions and miniHtmlImg
                for (const key in ORIGINAL_IMAGE_DEFINITIONS) {
                    OBJECT_TYPES[key] = { 
                        ...ORIGINAL_IMAGE_DEFINITIONS[key], 
                        miniHtmlImg: `<img src="${ORIGINAL_IMAGE_DEFINITIONS[key].path}" alt="${ORIGINAL_IMAGE_DEFINITIONS[key].name}" class="item-icon-inline">`
                    };
                }

                // Load Game Object Images
                for (const key in ORIGINAL_IMAGE_DEFINITIONS) {
                    const img = new Image();
                    img.src = ORIGINAL_IMAGE_DEFINITIONS[key].path;
                    img.onload = () => {
                        this.imagesLoadedMap[key] = img;
                        this.imagesLoadedCount++;
                        this.checkAllAssetsLoaded();
                    };
                    img.onerror = () => {
                        console.warn(`åœ–ç‰‡è¼‰å…¥å¤±æ•—: ${ORIGINAL_IMAGE_DEFINITIONS[key].path}ã€‚æ­¤ç‰©ä»¶å¯èƒ½ç„¡æ³•é¡¯ç¤ºã€‚`);
                        this.imagesLoadedMap[key] = null; // Store null if failed
                        this.imagesLoadedCount++;
                        this.checkAllAssetsLoaded();
                    };
                }

                this.setupMusicControls();
            }

            checkAllAssetsLoaded() {
                const totalExpectedLoads = this.totalImagesToLoad + 2; // All game images + FontAwesome + Mascot
                const currentLoads = this.imagesLoadedCount + (this.fontAwesomeLoaded ? 1 : 0) + (this.mascotLoaded ? 1 : 0);

                if (currentLoads === totalExpectedLoads) {
                    // Assign loaded Image objects to OBJECT_TYPES
                    for (const key in ORIGINAL_IMAGE_DEFINITIONS) {
                        OBJECT_TYPES[key].img = this.imagesLoadedMap[key];
                    }
                    this.postLoadSetup();
                }
            }

            postLoadSetup() {
                this.loadingOverlay.classList.add('hidden'); // Hide loading overlay
                this.gameWrapper.style.display = 'block'; // Show game wrapper FIRST
                
                this.resizeCanvas(); // Now resize canvas when it's visible and gets correct clientWidth

                this.score = 0;
                this.currentLevelIndex = 0;
                this.scoreDisplay.textContent = this.score;

                this.clearScreen(); // Clear canvas before setting up ready screen
                this.setupReadyScreen(); // NEW: Setup objects and UI for the ready screen
                this.updateInstructionsForbiddenList(); 
                
                // Start the game loop after everything is loaded and set up
                if (!this.animationFrameId) {
                    this.animationFrameId = requestAnimationFrame(this.drawGame.bind(this));
                }
            }

            // --- Event Listeners ---
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleCapture(this.getMousePos(e)));
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent scrolling on mobile
                    this.handleCapture(this.getMousePos(e));
                }, { passive: false });
                this.titleInstructionsButton.onclick = () => this.toggleInstructions();
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvasWidth = container.clientWidth;
                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight; // Ensure canvas dimensions are set
            }

            // --- Music & Sound Control ---
            setupMusicControls() {
                this.bgmAudio.volume = parseFloat(this.musicVolumeSlider.value);
                this.updateVolumeSliderFill();
                this.updateMusicButtonIcon();

                this.musicToggleButton.onclick = () => this.toggleBackgroundMusic();
                this.musicVolumeSlider.oninput = () => {
                    this.bgmAudio.volume = parseFloat(this.musicVolumeSlider.value);
                    this.updateMusicButtonIcon();
                    this.updateVolumeSliderFill();
                    if (this.bgmAudio.volume > 0 && this.bgmAudio.paused) {
                        this.bgmAudio.play().then(() => {
                            this.backgroundMusicPlayedOnceSuccessfully = true;
                            this.updateMusicButtonIcon();
                        }).catch(e => {
                            console.warn("èƒŒæ™¯éŸ³æ¨‚ç„¡æ³•åœ¨èª¿æ•´éŸ³é‡å¾Œæ’­æ”¾:", e.message);
                            this.updateMusicButtonIcon();
                        });
                    }
                };

                // Attempt autoplay on initial load, but don't block
                this.bgmAudio.play().then(() => {
                    this.backgroundMusicPlayedOnceSuccessfully = true;
                    this.updateMusicButtonIcon();
                }).catch(e => {
                    console.warn("èƒŒæ™¯éŸ³æ¨‚è‡ªå‹•æ’­æ”¾è¢«é˜»æ“‹ (é¦–æ¬¡è¼‰å…¥):", e.message);
                });
            }

            updateMusicButtonIcon() {
                if (this.bgmAudio.paused || this.bgmAudio.volume === 0) {
                    this.musicToggleButton.innerHTML = '<i class="fas fa-volume-mute"></i>';
                } else {
                    this.musicToggleButton.innerHTML = '<i class="fas fa-volume-up"></i>';
                }
            }

            updateVolumeSliderFill() {
                const volume = parseFloat(this.musicVolumeSlider.value);
                const min = parseFloat(this.musicVolumeSlider.min);
                const max = parseFloat(this.musicVolumeSlider.max);
                const percentage = ((volume - min) / (max - min)) * 100;
                this.musicVolumeSlider.style.background = `linear-gradient(to right, #8a2be2 0%, #00c4ff ${percentage}%, rgba(255,255,255,0.2) ${percentage}%, rgba(255,255,255,0.2) 100%)`;
            }

            toggleBackgroundMusic() {
                if (this.bgmAudio.paused) {
                    this.bgmAudio.play().then(() => {
                        this.backgroundMusicPlayedOnceSuccessfully = true;
                        this.updateMusicButtonIcon();
                    }).catch(e => {
                        console.error("èƒŒæ™¯éŸ³æ¨‚æ’­æ”¾å¤±æ•— (ç”¨æˆ¶é»æ“Š):", e);
                        this.updateMusicButtonIcon();
                    });
                } else {
                    this.bgmAudio.pause();
                    this.updateMusicButtonIcon();
                }
            }

            ensureBackgroundMusicPlays() {
                if (this.bgmAudio.paused && this.bgmAudio.volume > 0) { 
                    this.bgmAudio.play().then(() => {
                        this.backgroundMusicPlayedOnceSuccessfully = true;
                        this.updateMusicButtonIcon();
                    }).catch(e => {
                        console.warn("èƒŒæ™¯éŸ³æ¨‚æ¢å¾©æ’­æ”¾å¤±æ•— (å¯èƒ½è¢«ç€è¦½å™¨é˜»æ“‹):", e.message);
                        this.updateMusicButtonIcon(); 
                    });
                } else if (!this.bgmAudio.paused && this.bgmAudio.volume > 0) {
                    this.backgroundMusicPlayedOnceSuccessfully = true;
                }
            }

            playSound(frequency, duration, type = 'sine', decayTime = 0.1, volume = 0.5) {
                if (!this.audioContext || this.audioContext.state === 'suspended') {
                    this.audioContext.resume().then(() => {
                        this._createAndPlayOscillator(frequency, duration, type, decayTime, volume);
                    });
                } else {
                    this._createAndPlayOscillator(frequency, duration, type, decayTime, volume);
                }
            }

            _createAndPlayOscillator(frequency, duration, type, decayTime, volume) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                oscillator.type = type; 
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime); 
                gainNode.gain.exponentialRampToValueAtTime(0.0001, this.audioContext.currentTime + decayTime);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            // --- Game Logic ---
            // Sets up the initial screen with objects for the first level, but doesn't start the game.
            setupReadyScreen() {
                this.currentLevelIndex = 0; // Ensure we are looking at level 1 for the ready screen
                const level = LEVELS[this.currentLevelIndex];
                
                this.gameObjects = []; // Clear any previous objects
                this.timeLeft = level.duration; // Display initial duration
                this.timerDisplay.textContent = this.timeLeft.toFixed(1);
                
                // 1. Add required and forbidden items
                const initialObjectIds = new Set();
                [...level.required, ...level.forbidden].forEach(id => {
                    if (OBJECT_TYPES[id] && OBJECT_TYPES[id].img && !initialObjectIds.has(id)) { 
                        this.gameObjects.push(new GameObject(id, this.canvasWidth, this.canvasHeight));
                        initialObjectIds.add(id);
                    } else if (!OBJECT_TYPES[id] || !OBJECT_TYPES[id].img) {
                        console.warn(`Required/Forbidden item ${id} has no valid image.`);
                    }
                });

                // 2. Add bonus items with a chance
                if (Math.random() < level.bonusItemChance && OBJECT_TYPES['XIANG_WANG_LAI_FU'] && OBJECT_TYPES['XIANG_WANG_LAI_FU'].img) {
                    if (!initialObjectIds.has('XIANG_WANG_LAI_FU')) { 
                        this.gameObjects.push(new GameObject('XIANG_WANG_LAI_FU', this.canvasWidth, this.canvasHeight));
                        initialObjectIds.add('XIANG_WANG_LAI_FU');
                    }
                }

                // 3. Fill remaining slots with other random objects (filler items)
                const fillerCount = level.objectCount - this.gameObjects.length;
                for (let i = 0; i < fillerCount; i++) {
                    const randomFillerTypeId = this.getRandomFillerItem(level);
                    if (randomFillerTypeId) { 
                         this.gameObjects.push(new GameObject(randomFillerTypeId, this.canvasWidth, this.canvasHeight));
                    }
                }
                
                this.gameObjects = this.gameObjects.filter(obj => obj.img !== null); // Filter out any objects whose images failed to load

                this.updateMissionDisplay(level);
                this.levelDisplay.textContent = this.currentLevelIndex + 1;
                this.levelNameDisplay.textContent = `é™æ™‚ ${level.duration} ç§’ï¼Œæ‹åˆ°ä¸€æ¬¡å³å¯æ™‰ç´šï¼`; // Ensure level name is correctly reset

                this.gameMessage.textContent = 'é»æ“Šé–‹å§‹æŒ‰éˆ•ï¼Œæ•æ‰é›™æºªç¾æ™¯ï¼';
                this.startButton.textContent = 'é–‹å§‹æŒ‘æˆ°';
                this.startButton.onclick = () => this.startGame(); 
                this.gameOverlay.classList.remove('hidden'); 
                this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown
                
                this.gameState = 'ready'; // Set state to ready
                this.objectsAreFrozen = true; // Objects should be frozen when in 'ready' state
                this.highlightEffect = null; 
            }

            startGame() {
                this.ensureBackgroundMusicPlays(); 
                this.currentLevelIndex = 0; 
                this.score = 0; // Reset total score for a new game
                this.scoreDisplay.textContent = this.score;
                this.initLevel(this.currentLevelIndex); // This now fully initializes and starts the first level
            }

            resumeCapturing() {
                this.ensureBackgroundMusicPlays(); 
                this.objectsAreFrozen = false; 
                this.gameOverlay.classList.add('hidden'); 
                this.gameMessage.textContent = `é—œå¡ ${this.currentLevelIndex + 1}: ${LEVELS[this.currentLevelIndex].name} - å€’æ•¸ç¹¼çºŒ!`; 
                this.highlightEffect = null; 
                this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown
                // Adjust start time to resume countdown from where it was paused
                this.gameStartTime = performance.now() - (LEVELS[this.currentLevelIndex].duration - this.timeLeft) * 1000; 
            }

            initLevel(levelIndex) {
                this.ensureBackgroundMusicPlays(); 
                if (levelIndex >= LEVELS.length) {
                    this.gameState = 'win';
                    // Final game win message and score breakdown
                    this.gameMessage.innerHTML = `<span class="text-green-300 font-bold">ğŸ‰ æ­å–œ! å®Œæˆæ‰€æœ‰æŒ‘æˆ°!</span>`;
                    this.displayScoreBreakdown(true); // Show final score breakdown
                    this.startButton.textContent = 'é‡æ–°é–‹å§‹ (é—œå¡ 1)';
                    this.startButton.onclick = () => this.startGame();
                    this.gameOverlay.classList.remove('hidden'); 
                    this.objectsAreFrozen = true; 
                    return;
                }

                const level = LEVELS[levelIndex];
                this.currentLevelIndex = levelIndex; 
                this.currentLevelScore = 0; // Reset current level score
                
                this.gameObjects = []; 
                this.timeLeft = level.duration;
                this.timerDisplay.textContent = this.timeLeft.toFixed(1);
                
                // 1. Add required and forbidden items
                const initialObjectIds = new Set();
                [...level.required, ...level.forbidden].forEach(id => {
                    if (OBJECT_TYPES[id] && OBJECT_TYPES[id].img && !initialObjectIds.has(id)) { 
                        this.gameObjects.push(new GameObject(id, this.canvasWidth, this.canvasHeight));
                        initialObjectIds.add(id);
                    } else if (!OBJECT_TYPES[id] || !OBJECT_TYPES[id].img) {
                        console.warn(`Required/Forbidden item ${id} has no valid image.`);
                    }
                });

                // 2. Add bonus items with a chance
                if (Math.random() < level.bonusItemChance && OBJECT_TYPES['XIANG_WANG_LAI_FU'] && OBJECT_TYPES['XIANG_WANG_LAI_FU'].img) {
                    if (!initialObjectIds.has('XIANG_WANG_LAI_FU')) { 
                        this.gameObjects.push(new GameObject('XIANG_WANG_LAI_FU', this.canvasWidth, this.canvasHeight));
                        initialObjectIds.add('XIANG_WANG_LAI_FU');
                    }
                }

                // 3. Fill remaining slots with other random objects (filler items)
                const fillerCount = level.objectCount - this.gameObjects.length;
                for (let i = 0; i < fillerCount; i++) {
                    const randomFillerTypeId = this.getRandomFillerItem(level);
                    if (randomFillerTypeId) { 
                         this.gameObjects.push(new GameObject(randomFillerTypeId, this.canvasWidth, this.canvasHeight));
                    }
                }
                
                this.gameObjects = this.gameObjects.filter(obj => obj.img !== null);


                this.updateMissionDisplay(level);
                this.levelDisplay.textContent = levelIndex + 1;
                this.gameMessage.textContent = `é—œå¡ ${levelIndex + 1}: ${level.name} - å€’æ•¸é–‹å§‹!`; 
                this.gameOverlay.classList.add('hidden'); 
                this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown for new level
                
                this.gameState = 'playing';
                this.objectsAreFrozen = false; // Unfreeze objects for actual play
                this.highlightEffect = null; 
                this.gameStartTime = performance.now(); // Reset timer
            }

            // Dynamically update the mission display area
            updateMissionDisplay(level) {
                const getMissionItemsElements = (itemIds) => {
                    const fragment = document.createDocumentFragment();
                    itemIds.forEach(id => {
                        const objDef = OBJECT_TYPES[id]; 
                        // Only create elements if objDef and its miniHtmlImg are available
                        if (objDef && objDef.miniHtmlImg && objDef.name) {
                            const wrapper = document.createElement('span');
                            wrapper.classList.add('mission-item-wrapper');
                            // Using innerHTML here for simplicity of already formatted miniHtmlImg
                            wrapper.innerHTML = objDef.miniHtmlImg + ' ' + objDef.name; 
                            fragment.appendChild(wrapper);
                        }
                    });
                    return fragment;
                };
                
                this.targetsDisplay.innerHTML = ''; // Clear previous content
                this.targetsDisplay.appendChild(getMissionItemsElements(level.required));

                this.forbiddenDisplay.innerHTML = ''; // Clear previous content
                this.forbiddenDisplay.appendChild(getMissionItemsElements(level.forbidden));
                
                this.levelNameDisplay.textContent = `é™æ™‚ ${level.duration} ç§’ï¼Œæ‹åˆ°ä¸€æ¬¡å³å¯æ™‰ç´šï¼`;
            }

            // Dynamically update instructions modal forbidden list
            updateInstructionsForbiddenList() {
                this.instructionsForbiddenList.innerHTML = '';
                GLOBAL_FORBIDDEN_ITEMS.forEach(id => {
                    const objDef = OBJECT_TYPES[id];
                    if (objDef && objDef.miniHtmlImg && objDef.name) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'pr-4', 'pb-1');
                        listItem.innerHTML = objDef.miniHtmlImg + ' ' + objDef.name;
                        this.instructionsForbiddenList.appendChild(listItem);
                    }
                });
            }

            handleCapture(pos) { 
                if (this.gameState !== 'playing' || this.objectsAreFrozen) return; 

                this.captureEffect = { x: pos.x, y: pos.y, startTime: performance.now() };
                this.playSound(300, 0.05, 'square', 0.02); 
                this.ensureBackgroundMusicPlays(); 

                const level = LEVELS[this.currentLevelIndex];
                let visibleTargetsDetected = new Set();    
                let visibleForbiddenDetected = new Set();  
                let visibleBonusItemsDetectedCount = 0;        
                
                let itemsToHighlight = []; 

                for (const obj of this.gameObjects) {
                    if (obj.isVisibleOnCanvas()) { 
                        if (level.required.includes(obj.typeId)) {
                            visibleTargetsDetected.add(obj.typeId);
                            itemsToHighlight.push({ obj: obj, color: '#00e0b7' }); 
                        } else if (level.forbidden.includes(obj.typeId)) {
                            visibleForbiddenDetected.add(obj.typeId);
                            itemsToHighlight.push({ obj: obj, color: '#ff69b4' }); 
                        } else if (obj.typeId === 'XIANG_WANG_LAI_FU' && obj.isBonus) { 
                            visibleBonusItemsDetectedCount++;
                        }
                    }
                }

                let isCurrentSnapshotSuccessful = false;
                let failureReason = null;

                if (visibleForbiddenDetected.size > 0) {
                    failureReason = `æ•æ‰åˆ°ç¦å¿Œç‰©å“ï¼š${Array.from(visibleForbiddenDetected).map(id => OBJECT_TYPES[id].name).join('ã€')}ï¼`;
                    itemsToHighlight = itemsToHighlight.filter(item => item.color === '#ff69b4'); 
                    
                } else { 
                    const currentLevelRequiredTargets = LEVELS[this.currentLevelIndex].required;
                    const allRequiredTargetsVisible = currentLevelRequiredTargets.length > 0 && currentLevelRequiredTargets.every(reqId => visibleTargetsDetected.has(reqId));

                    if (allRequiredTargetsVisible) {
                        isCurrentSnapshotSuccessful = true; 
                        itemsToHighlight = itemsToHighlight.filter(item => item.color === '#00e0b7'); 
                    } else {
                        isCurrentSnapshotSuccessful = false; 
                        itemsToHighlight = []; 
                    }
                }
                
                this.objectsAreFrozen = true; 

                if (isCurrentSnapshotSuccessful || failureReason !== null) {
                    let levelScoreBreakdown = {
                        base: 0,
                        timeBonus: 0,
                        targetBonus: 0,
                        bonusItems: 0,
                        total: 0
                    };

                    if (isCurrentSnapshotSuccessful) {
                        levelScoreBreakdown.base = SCORE_PER_CAPTURE;
                        this.currentLevelScore += SCORE_PER_CAPTURE;

                        // Bonus items score
                        const bonusItemPoints = visibleBonusItemsDetectedCount * BONUS_ITEM_SCORE;
                        levelScoreBreakdown.bonusItems = bonusItemPoints;
                        this.currentLevelScore += bonusItemPoints;
                        for (let i = 0; i < visibleBonusItemsDetectedCount; i++) {
                            // Find a bonus item to display message
                            const bonusObj = this.gameObjects.find(obj => obj.typeId === 'XIANG_WANG_LAI_FU' && obj.isVisibleOnCanvas());
                            if (bonusObj) this.displayBonusMessage(bonusObj.x, bonusObj.y, BONUS_ITEM_SCORE);
                        }

                        // Time bonus
                        const timeBonus = Math.max(0, Math.floor(this.timeLeft)) * TIME_BONUS_MULTIPLIER;
                        levelScoreBreakdown.timeBonus = timeBonus;
                        this.currentLevelScore += timeBonus;

                        // Target quantity bonus
                        const targetBonus = visibleTargetsDetected.size * TARGET_BONUS_PER_ITEM;
                        levelScoreBreakdown.targetBonus = targetBonus;
                        this.currentLevelScore += targetBonus;

                        this.score += this.currentLevelScore; // Add current level score to total score
                    }

                    levelScoreBreakdown.total = this.currentLevelScore; // Total for this level before displaying

                    this.scoreDisplay.textContent = this.score; // Update total display
                    this.checkLevelEnd(isCurrentSnapshotSuccessful, failureReason, itemsToHighlight, levelScoreBreakdown);
                } else {
                    this.gameMessage.innerHTML = `<span class="text-gray-400">å¿«ç…§å®Œæˆï¼é‚„éœ€åŠªåŠ›ï¼</span>`;
                    this.startButton.textContent = 'ç¹¼çºŒæ•æ‰';
                    this.startButton.onclick = () => this.resumeCapturing();
                    this.gameOverlay.classList.remove('hidden'); 
                    this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown
                    this.highlightEffect = null; 
                }
            }


            checkLevelEnd(success, reason = null, itemsToHighlight = [], levelScoreBreakdown = null) {
                this.gameOverlay.classList.remove('hidden'); 
                this.highlightEffect = { type: success ? 'success' : 'failure', items: itemsToHighlight, startTime: performance.now() }; 

                if (success) {
                    this.gameMessage.innerHTML = `<span class="text-green-300 font-bold"><i class="fas fa-trophy"></i> æ•æ‰æˆåŠŸ!</span>`;
                    this.displayScoreBreakdown(false, levelScoreBreakdown); // Show breakdown for successful level
                    this.startButton.textContent = 'ä¸‹ä¸€é—œ';
                    this.startButton.onclick = () => {
                        this.highlightEffect = null; 
                        this.initLevel(this.currentLevelIndex + 1);
                    };
                    this.playSound(800, 0.15, 'sine', 0.1); 
                    
                } else {
                    this.gameState = 'lose';
                    this.gameMessage.innerHTML = `<span class="text-red-300 font-bold"><i class="fas fa-times-circle"></i> ä»»å‹™å¤±æ•—!</span> ${reason ? 'åŸå› : ' + reason : 'æ™‚é–“ç”¨ç›¡äº†!'}`;
                    this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown on failure
                    this.startButton.textContent = 'å†è©¦ä¸€æ¬¡';
                    this.startButton.onclick = () => {
                        this.highlightEffect = null; 
                        this.initLevel(this.currentLevelIndex);
                    };
                    this.playSound(150, 0.2, 'square', 0.1); 
                }
            }

            displayScoreBreakdown(isFinalGameEnd = false, levelScoreBreakdown = null) {
                this.scoreBreakdownElement.innerHTML = ''; // Clear previous content
                this.scoreBreakdownElement.classList.remove('hidden');

                if (isFinalGameEnd) {
                    // Final game end - show total score only
                    const totalP = document.createElement('p');
                    totalP.classList.add('total-score');
                    totalP.innerHTML = `<span>éŠæˆ²ç¸½åˆ†</span> <span>${this.score}</span>`;
                    this.scoreBreakdownElement.appendChild(totalP);
                } else if (levelScoreBreakdown) {
                    // Level success - show breakdown for current level
                    const baseP = document.createElement('p');
                    baseP.innerHTML = `<span>åŸºç¤åˆ†</span> <span>+${levelScoreBreakdown.base}</span>`;
                    this.scoreBreakdownElement.appendChild(baseP);

                    const timeP = document.createElement('p');
                    timeP.innerHTML = `<span>æ™‚é–“çå‹µ (å‰©é¤˜ ${Math.max(0, Math.floor(this.timeLeft))}ç§’)</span> <span>+${levelScoreBreakdown.timeBonus}</span>`;
                    this.scoreBreakdownElement.appendChild(timeP);

                    const targetP = document.createElement('p');
                    targetP.innerHTML = `<span>ç›®æ¨™æ•¸é‡çå‹µ</span> <span>+${levelScoreBreakdown.targetBonus}</span>`;
                    this.scoreBreakdownElement.appendChild(targetP);

                    const bonusP = document.createElement('p');
                    bonusP.innerHTML = `<span>çå‹µç‰©å“åˆ†</span> <span>+${levelScoreBreakdown.bonusItems}</span>`;
                    this.scoreBreakdownElement.appendChild(bonusP);

                    const totalP = document.createElement('p');
                    totalP.classList.add('total-score');
                    totalP.innerHTML = `<span>æœ¬é—œå¾—åˆ†</span> <span>${levelScoreBreakdown.total}</span>`;
                    this.scoreBreakdownElement.appendChild(totalP);
                }
            }


            displayBonusMessage(x, y, points) {
                this.bonusMessages.push({
                    x: x,
                    y: y,
                    text: `+${points} BONUS!`,
                    startTime: performance.now(),
                    color: '#00e0b7' 
                });
                this.playSound(600, 0.1, 'sine', 0.05); 
            }

            // --- Drawing and Animation Loop ---
            clearScreen() {
                this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
                this.ctx.fillStyle = '#3a005f'; // Match the darker part of the canvas-container gradient
                this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            }

            updateGameTime(currentTime) {
                if (this.gameState === 'playing' && !this.objectsAreFrozen) {
                    const elapsed = (currentTime - this.gameStartTime) / 1000;
                    this.timeLeft = LEVELS[this.currentLevelIndex].duration - elapsed;
                    
                    if (this.timeLeft <= 0) {
                        this.timeLeft = 0;
                        this.timerDisplay.textContent = '0.0';
                        this.checkLevelEnd(false); // Time's up
                        return;
                    }
                    this.timerDisplay.textContent = this.timeLeft.toFixed(1);
                }
            }

            drawGame(currentTime) {
                if (!this.lastFrameTime) this.lastFrameTime = currentTime;
                // const deltaTime = currentTime - this.lastFrameTime; // Delta time for framerate independent updates, currently not used for object movement
                this.lastFrameTime = currentTime;

                this.clearScreen();
                this.updateGameTime(currentTime); // Update time based on current frame

                const level = LEVELS[this.currentLevelIndex];
                const speedMultiplier = level ? level.speedMultiplier : 1.0;
                
                // Update and draw objects
                for (let i = this.gameObjects.length - 1; i >= 0; i--) {
                    const obj = this.gameObjects[i];
                    obj.update(speedMultiplier); 
                    obj.draw();
                    
                    // Only respawn objects if game is playing and objects are not frozen
                    if (this.gameState === 'playing' && !this.objectsAreFrozen && obj.isOffScreen()) { 
                        this.gameObjects.splice(i, 1);
                        const newFillerItem = this.getRandomFillerItem(level);
                        if (newFillerItem) {
                            this.gameObjects.push(new GameObject(newFillerItem, this.canvasWidth, this.canvasHeight));
                        }
                    }
                }
                
                // Capture effect
                if (this.captureEffect) {
                    const elapsed = currentTime - this.captureEffect.startTime;
                    const duration = 200; 
                    if (elapsed < duration) {
                        const alpha = 1 - (elapsed / duration); 
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                        this.ctx.globalAlpha = 1.0;
                    } else {
                        this.captureEffect = null;
                    }
                }

                // Bonus messages
                for (let i = this.bonusMessages.length - 1; i >= 0; i--) {
                    const msg = this.bonusMessages[i];
                    const elapsed = currentTime - msg.startTime;
                    const duration = 1000; 

                    if (elapsed < duration) {
                        const alpha = 1 - (elapsed / duration);
                        this.ctx.save();
                        this.ctx.font = 'bold 24px Inter';
                        this.ctx.fillStyle = msg.color;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'bottom';
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillText(msg.text, msg.x, msg.y - (elapsed / 20)); 
                        this.ctx.restore();
                    } else {
                        this.bonusMessages.splice(i, 1);
                    }
                }

                // Highlight effect
                if (this.highlightEffect) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 1.0; 
                    this.ctx.lineWidth = 4;

                    for (const item of this.highlightEffect.items) {
                        if (item.obj.isVisibleOnCanvas()) { 
                            this.ctx.strokeStyle = item.color; 
                            this.ctx.beginPath();
                            this.ctx.arc(item.obj.x, item.obj.y, item.obj.size / 2 + 10, 0, Math.PI * 2); 
                            this.ctx.stroke();
                        }
                    }
                    this.ctx.restore();
                }

                this.animationFrameId = requestAnimationFrame(this.drawGame.bind(this));
            }

            // Helper to get a random filler item (not required, not forbidden, not bonus)
            getRandomFillerItem(level) {
                const excludedTypes = new Set([...level.required, ...level.forbidden, 'XIANG_WANG_LAI_FU']);
                const availableFillerTypes = Object.keys(OBJECT_TYPES).filter(id => 
                    !excludedTypes.has(id) && OBJECT_TYPES[id] && OBJECT_TYPES[id].img !== null
                );
                if (availableFillerTypes.length === 0) {
                    console.warn("No suitable filler items available. Consider adding more item types or adjusting level settings.");
                    return null; // No suitable item found
                }
                const randomTypeId = availableFillerTypes[Math.floor(Math.random() * availableFillerTypes.length)];
                return randomTypeId;
            }

            // --- Instructions Modal ---
            toggleInstructions() {
                this.instructionsModal.classList.toggle('hidden');
            }
        }

        // Initialize the game instance
        const gameInstance = new Game();
        document.addEventListener('DOMContentLoaded', () => gameInstance.init());

    </script>
</body>
</html>